#! /bin/sh

# easy(1): interact with HTTP servers and REST services
#
# Yves Arrouye

: ${TMPDIR:=/tmp}
me=`basename $0`

: ${XDG_CONFIG_HOME:=$HOME/.config}
: ${XDG_CONFIG_DIRS:=/etc/xdg}
: ${XDG_DATA_HOME:=$HOME/.local/share}
: ${XDG_DATA_DIRS:=/usr/local/share/:/usr/share/}

# If invoked as rest(1), use baked and cooked modes by default and assume
# one wants JSON.

case "$me" in
    rest)
	default_content=json
	default_baked=1
	default_cooked=1
	;;
esac

#

easy_methods="DELETE HEAD GET OPTIONS PATCH POST PUT TRACE"

usage() {
    if [ "$1" -eq 0 ]
    then
        u=U
    else
        u=u
        exec >&2
    fi
    echo $u"sage: $me [--help] [--print [-s] [-p prefix] [[no]env,[no]func,all]] [--cmd file] [--no-env] [--no-extras] [-j, --json | -f, --form | -a, --as-is ] [-B, --baked] [-W, --wet] [-C, --cooked] [-R, --raw] [--endpoint endpoint] [-q, --query query] [-O, --override] [-V]  method resource [data] [curlopt ...]"
    if [ "$1" -eq 0 ]
    then
        cat <<EOF

       --help               Show this message
       --print [opts] what  Print commands to set env or define HTTP functions
       --cmd file           Print the curl(1) command to file
       --no-env             Do not use environment variables
       --no-extras          Do not add extra behavior not explicitly asked for
       -j, --json           Send and receive JSON data
       -f, --form           Send and receive form data
       -a, --as-is          Send and receive data without modifications
       -B, --baked          Bake data from command line
       -W, --wet	    Do not bake data from command line
       -C, --cooked         Cook response contents
       -R, --raw	    Do not cook response contents
       --endpoint endpoint  Specifies an endpoint (overrides \$EASYENDPOINT)
       -q, --query query    Include the query with the path
       -O, --override       Override POST with the chosen method
       -V                   Create needed data using an editor if possible
       resource             Resource to operate on
       data                 Data for methods taking data as input
       curlopt ...	    Options for curl(1) in addition to \$RESCURLTOPTS
EOF
    fi

    exit $1
}

urlencode() {
  echo "$*" | sed 's/%/%25/g;s/\[/%5B/g;s/\]/%5D/g;s/|/%7C/g;s/\$/%24/g;s/&/%26/g;s/+/%2B/g;s/,/%2C/g;s/:/%3A/g;s/;/%3B/g;s/=/%3D/g;s/?/%3F/g;s/@/%40/g;s/ /%20/g;s/#/%23/g;s/{/%7B/g;s/}/%7D/g;s/\\/%5C/g;s/\^/%5E/g;s/~/%7E/g;s/`/%60/g'
}

quotestr() {
    echo ${1+"$@"} | sed 's/"/\\\"/g'
}

quote() {
    if [ "$1" = "--in-quotes" ]
    then 
        quote="'"'"'"'"
        shift
    else
	quote="'"
    fi
    qargs=
    for a
    do
	if echo $a | grep -q "[ 	&\"'\
]"
	then
	    q=$quote`echo $a | sed "s/'/'\"'\"/g"`$quote
	    qargs="$qargs $q"
	else
	    if [ -z "$a" ]
	    then
		qargs="$qargs '$a'"
	    else
		qargs="$qargs $a"
	    fi
	fi
    done
    echo "$qargs" | sed 's/^ //'
}

callcurl() {
    if [ "0$cooked" -gt 0 ]
    then
	hdrfile=`mktemp $TMPDIR/$me.XXXXXX`
	contentfile=`mktemp $TMPDIR/$me.XXXXXX`
	trap "rm -f $hdrfile $contentfile" 0 1 2 3 4 5 6 7 8 15

	curl ${1+"$@"} -D $hdrfile -o $contentfile
	res=$?

    	if [ "0$cooked" -gt 1 ]
	then
	    prettyarg=-C
	fi
	if [ -f $hdrfile ]
	then
	    grep -v '^Transfer-Encoding:' $hdrfile | pretty $prettyarg 2>/dev/null
	    echo
	    type="`sed -n 's/^Content-Type:[ 	]*\([^;]*\).*$/\1/p' $hdrfile | tr -d '[\012\015]'`"
	fi
	if [ -f "$contentfile" ]
	then
	    if [ -z "$type" ]
	    then
	        type="`mime -qEC $contentfile 2>/dev/null`"
	    fi
	    pretty $prettyarg $contentfile 2>/dev/null
	fi
	rm -f $hdrfile $contentfile
    else
        curl ${1+"$@"}
	res=$?
    fi
    if [ -n "$printfile" ]
    then
	if [ "$printfile" != "-" ]
	then
	    exec >$printfile || exit "$me: could not write to $printfile"
	fi
	quote curl ${1+"$@"}
    fi
    exit $res
}

call() {
    method=$1
    shift
    resource=$1
    shift

    proto=`echo $EASYENDPOINT | sed -e 's,:.*,,'`
    host=`echo $EASYENDPOINT | sed -e 's,^[a-z]*://\(.*\),\1,' -e 's,/.*,,'`
    hostdir=`echo $host | sed -e 's,:, ,g'`

    urlbase=`echo $EASYENDPOINT | sed 's,/$,,'`

    datafile=
    case "$method" in
	TRACE)
	    xopt="-X $method"
	    takesdata=yes
	    ;;
 	POST)
	    case "$content" in
	        json|asis)
		    dataopt=--data-binary
		    ;;
		form)
		    dataopt=--data-urlencode
		    ;;
	    esac	
	    datafileprefix=@
	    takesdata=yes
	    ;;
 	PUT)
	    dataopt=-T
	    datafileprefix=
	    takesdata=yes
	    ;;
	GET)
	    opt=-G
	    takesdata=yes
	    ;;
	HEAD)
	    opt=-I
	    raw=1
	    ;;
    esac

    if [ -n "$takesdata" ]
    then
	nodatagiven=
	if [ "0$baked" -ne 0 ]
	then
	    data=""
	    if [ "$content" = json ]
	    then
		datastart="{"
		dataend="}"
		datasep=","
	    else
		datastart=
		dataend=
		datasep="&"
	    fi
	    for arg
	    do
		case "$arg" in
		    [^-]*=*)
			key=`echo $arg | sed -E 's/^([^:=]+):?=.*/\1/'`
			val=`echo $arg | sed -E 's/^[^:=]+:?=(.*)/\1/'`
			literal=`echo $arg | grep -Eq '/^[:=][^:=]'`
			if [ -z "$data" ]
			then
			    data="$datastart"
			else
			    data="$data$datasep"
			fi
	    	        if [ "$content" = json ]
			then
			    data="$data"'"'"`quotestr $key`"'"'"="
			    if [ -n "$literal" ]
			    then
				data="$data`quote $val`"
			    else
				data="$data"'"'"`quotestr $val`"'"'
			    fi
			else
			    data="$data`urlencode $key`=`urlencode $val`"
			fi
			shift
			;;
		    *)
			break
			;;
		esac
	    done
	    if [ -n "$data" ]
	    then
		data="$data$dataend"
	    fi
	else
	case "$1" in
	    -)
		data="@-"
		shift
		;;
	    -*)
		nodatagiven=1
		;;
	    *)
		data="$1"
		shift
		;;
	esac
	fi

	if [ -n "$useeditor" ]
	then
	    if [ -n "$nodatagiven" -o -z "$data" ]
	    then
		nodata=1
	    fi
	    if [ "$useeditor" == "yesyes" -o -n "nodata" ]
	    then
		editor=`(exec 2>/dev/null; which "$VISUAL" || which "$EDITOR" \
                           || which vim || which vi) | tail -n 1`
		if [ -n "$editor" ]
		then
		    tmpfile=`mktemp $TMPDIR/$me.XXXXXX`
		    if [ -n "$nodata" ]
		    then
			if [ ! -t 0 ]
			then
			    cat >$tmpfile
			fi
		    else
			echo "$data" >$tmpfile
		    fi
		    (exec </dev/tty; "$editor" $tmpfile)
		    data=`cat $tmpfile`
		    rm -f $tmpfile
		fi
	    fi
	fi
    fi

    if [ -n "$httpoverride" ]
    then
	httpoverride="X-HTTP-Override: $method"
	method=POST
    fi

    if [ "$content" = json ]
    then
	contenthdr="Content-Type: application/json; charset=utf-8"
	accepthdr="Accept: application/json; charset=utf-8"
    fi

    if [ -n "$dataopt" ]
    then
        datafile=$TMPDIR/`mktemp $me.XXXXXX`
        echo "$data" >$datafile
        data="$datafileprefix$datafile"
    fi

    callcurl $mycurlopts $EASYCURLOPTS $opt $dataopt $data \
	$xopt -H "$httpoverride" -H "$contenthdr" -H "$accepthdr" \
        $EASYCURLOPTS ${1+"$@"} $urlbase$resource

    rm -f $datfile
}

#

takeiteasy() {
    while [ $# -ne 0 ]
    do
	donotquotearg=
	firstquotearg=
	case "$1" in
	    -[^-]*)
		for l in `echo $1 | sed -e 's/^-//' -e 's/\(.\)/\1 /g'`
		do
		    curlopt=
		    case "$l" in
			j)
			    content=json
			    ;;
			f)
			    content=form
			    ;;
			a)
			    content=asis
			    ;;
			B)
			    baked=1
			    ;;
			W)
			    baked=0
			    ;;
			C)
			    cooked=`expr 0$cooked + 1`
			    ;;
			R)
			    cooked=0
			    ;;
			q)
			    test $# -gt 1 || usage 1
			    firstquotearg="$1"
			    shift
			    query="?$1"
			    ;;
			O)
			    httpoverride=1
			    ;;
			V)
			    case "$useeditor" in
				yes)
				    useeditor="${useeditor}yes"
				    ;;
				"")
				    useeditor=1
				    ;;
			    esac
			    ;;
			*)
			    if [ "$1" != "-$l" ]
			    then
				usage 1     # Our options, unknown letter
			    else
				curlopt=1
				break       # cURL option
			    fi
			    ;;
		    esac
		done
		if [ -n "$curlopt" ]
		then
		    donotquotearg=1
		    break
		fi
		;;
	    --help)
		usage 0
		;;
	    --cmd)
		test $# -gt 1 || usage 1
		firstquotearg="$1"
		shift
		printfile=$1
		;;
	    --print)
		test $# -gt 1 || usage 1
		shift
		donotquotearg=1
		while [ $# -gt 1 ]
		do
		    case "$1" in
			-[^-]*)
			    for l in `echo $1 | sed -e 's/^-//' -e 's/\(.\)/\1 /g'`
			    do
				case "$l" in
				    s)
					printselfcontained=1
					;;
				    p)
					test $# -gt 1 || usage 1
					shift
					printprefix="$1"
					;;
				    *)
					usage 1
					;;
				esac
			    done
			    ;;
			*)
			    break
			    ;;
		    esac
		    shift
		done
		printshell=$1
		for f in `echo $printshell | sed 's/,/ /g'`
		do
		    case "$f" in
			env)
			    ;;
			noenv)
			    noprintenv=1
			    ;;
			func)
			    ;;
			nofunc)
			    noprintshellcmd=1
			    ;;
			all)
			    printall=1
			    ;;
			*)
			    >&2 echo $me: unknown --print argument: $f && exit 5
			    ;;
		    esac
		done
		;;
	    --no-env)
		noenv=1
		;;
	    --no-extras)
		clean=1
		;;
	    --json)
		content=json
		;;
	    --form)
		content=form
		;;
	    --as-is)
		content=asis
		;;
	    --baked)
		baked=1
		;;
	    --wet)
		baked=0
		;;
	    --cooked)
		cooked=`expr 0$cooked + 1`
		;;
	    --raw)
		cooked=0
		;;
	    --endpoint)
		test $# -gt 1 || usage 1
		donotquotearg=1
		shift
		EASYENDPOINT=$1
		;;
	    --override)
		httpoverride=1
		;;
	    --query)
		test $# -gt 1 || usage 1
		firstquotearg="$1"
		shift
		query="?$1"
		;;
	    -*)
		break
		;;
	    *)
		if [ -z "$method" ]
		then
		    method=$1
		    if [ -n "$printshellcmd" ]
		    then
			shift
			break
		    fi
		else
		    break
		fi
		;;
	esac
	if [ -z "$donotquotearg" ]
	then
	    if [ -n "$firstquotearg" ]
	    then
		quotedarg=`quote "$firstquotearg"`
		quotedargs="$quotedargs $quotedarg"
	    fi
            quotedarg=`quote "$1"`
	    quotedargs="$quotedargs $quotedarg"
	fi
	shift
    done

    : ${content:=$default_content}
    : ${baked:=$default_baked}
    : ${cooked:=$default_cooked}

    if [ -n "$noenv" ]
    then
	unset EASYENDPOINTS
	unset EASYCURLOPTS
    fi
    if [ -z "$clean" ]
    then
	mycurlopts=-LsS
    fi

    if [ -n "$printshell" ]
    then
    # Process the --print arguments in the order we have seen then

	if [ -n "$printselfcontained" ]
	then
	    allargs=${printall:+func}
	else
	    allargs=${printall:+env,func,config}
	fi
	
	for f in `echo $printshell,$allargs | sed 's/,/ /g'`
	do
	    case "$f" in
		env)
		    if [ -z "$noprintenv" ]
		    then
			case "${SHELL:-/bin/sh}" in
			    csh|*/csh*|tcsh|*/tcsh*)
				export="setenv"
				exporteq=" "
				;;
			    *)
				export="export"
				exporteq="="
				;;
			esac
			test -n "$EASYENDPOINT" && echo "$export EASYENDPOINT$exporteq`quote $EASYENDPOINT`;"
		    fi
		    ;;
		func)
		    if [ -z "$noprintshellcmd" ]
		    then
			print_methods=${method:-$easy_methods}
			case "${SHELL:-/bin/sh}" in
			    csh|*/csh*|tcsh|*/tcsh*)
				csh=1
				quoteforsh=--in-quotes
				;;
			esac
			if [ -n "$printselfcontained" ]
			then
			    test -n "$EASYENDPOINT" && endpointarg=" --endpoint `quote $quoteforsh $EASYENDPOINT`"
			    test -n "$EASYCURLOPTS" && easycurloptsarg=" `quote $quoteforsh $EASYCURLOPTS`"
			fi
			if [ -n "$printconfig" ]
			then
			    :
			    shift $#
			else
    			    args=`quote $quoteforsh ${1+"$@"}`
			    if [ -n "$printselfcontained" ]
			    then
				if [ -n "$easycurloptsarg" ]
				then
				    easyargs="$easycurloptsarg"
				fi
		     		easyargs=" --no-env$easyargs$endpointarg"
			    fi
			fi
			if [ -n "$args" ]
			then
			    args=" $args"
			fi
			if [ -n "$csh" ]
			then
			    if [ -n "$args" ]
			    then
				aliasargs=' \!*'
			    fi
			    for method in $print_methods
			    do
				cat <<EOF
alias $printprefix$method '$me$easyargs$quotedargs $method$aliasargs$args';
EOF
			    done
			else
			    for method in $print_methods
			    do
				cat <<EOF
$printprefix$method () {
    $me$easyargs$quotedargs $method "\$@"$args
};
EOF
			    done
			fi
		    fi
		    ;;
	    esac
	done

	exit 0
    fi

#

    if [ -z "$method" ]
    then
	test $# -ge 1 || usage 1
	method=$1
	shift
    fi

    if echo " $easy_methods " | fgrep -q " $method "
    then
	if [ -n "$assumecmdname" ]
	then
	    me=$method
	fi
	
    # See if the resource path is actually a URI. If so, extract the
    # endpoint ans resource path from there and pass the computed resource
    # path for the call.

	case "`echo $1 | tr '[A-Z]' '[a-z]'`" in
	    http://*|https://*)
		EASYENDPOINT=`echo $1 | sed 's,^\([^/]*:///*[^/]*\).*,\1,'`
		resourcepath=`echo $1 | sed 's,^[^/]*:///*[^/]*\(.*\),\1,'`
		shift
		;;
	esac
	if [ -z "$EASYENDPOINT" ]
	then
	    >&2 echo $me: unable to determine an endpoint to call
	    exit 2
	fi
	
	call $method $resourcepath$query ${1+"$@"}
    else
	case "$method" in
	    -*)
		usage 1
		;;
	    *)
		>&2 echo $me: unknown method: $method
		exit 6
		;;
	esac
    fi
}

# Do a quick check for --no-env first...

for arg
do
    case "$arg" in
	--no-env)
	    noenv=yes
	    ;;
        -*)
	    ;;
	*)
	    break
	    ;;
    esac
done

if [ -n "$noenv" ]
then
    unset EASYOPTS
fi

takeiteasy $EASYOPTS ${1+"$@"}

